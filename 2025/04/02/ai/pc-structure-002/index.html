<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start -->
<link rel="stylesheet" href="/ai-classroom/css/bilicard.css">
<!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第二章 网络分层的概念 | 生命不息，学习不止</title><meta name="author" content="lifespace"><meta name="copyright" content="lifespace"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第二章 OSI 和 TCP&#x2F;IP 网络分层模型详解 2.1 网络分层 复杂的系统需要分层来考虑和解决，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。  各层之间相互独立：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）。这样不同厂商可以专注于解决不同的事情，甚至不同厂商提供的设备，只">
<meta property="og:type" content="article">
<meta property="og:title" content="第二章 网络分层的概念">
<meta property="og:url" content="https://alifespace.github.io/2025/04/02/ai/pc-structure-002/index.html">
<meta property="og:site_name" content="生命不息，学习不止">
<meta property="og:description" content="第二章 OSI 和 TCP&#x2F;IP 网络分层模型详解 2.1 网络分层 复杂的系统需要分层来考虑和解决，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。  各层之间相互独立：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）。这样不同厂商可以专注于解决不同的事情，甚至不同厂商提供的设备，只">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://alifespace.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-04-02T14:58:37.000Z">
<meta property="article:modified_time" content="2025-05-09T05:00:59.000Z">
<meta property="article:author" content="lifespace">
<meta property="article:tag" content="TCP&#x2F;IP">
<meta property="article:tag" content="OSI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://alifespace.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第二章 网络分层的概念",
  "url": "https://alifespace.github.io/2025/04/02/ai/pc-structure-002/",
  "image": "https://alifespace.github.io/img/butterfly-icon.png",
  "datePublished": "2025-04-02T14:58:37.000Z",
  "dateModified": "2025-05-09T05:00:59.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "lifespace",
      "url": "https://alifespace.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/ai-classroom/img/favicon.png"><link rel="canonical" href="https://alifespace.github.io/2025/04/02/ai/pc-structure-002/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/ai-classroom/css/index.css?v=5.4.0-b2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-39ZQR3BVZ9"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-39ZQR3BVZ9')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-39ZQR3BVZ9', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/ai-classroom/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第二章 网络分层的概念',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/ai-classroom/"><span class="site-name">生命不息，学习不止</span></a><a class="nav-page-title" href="/ai-classroom/"><span class="site-name">第二章 网络分层的概念</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">第二章 网络分层的概念</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-02T14:58:37.000Z" title="发表于 2025-04-02 07:58:37">2025-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-09T05:00:59.000Z" title="更新于 2025-05-08 22:00:59">2025-05-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/ai-classroom/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/ai-classroom/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A1%AC%E4%BB%B6/">硬件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>第二章 OSI 和 TCP/IP 网络分层模型详解</h1>
<h2 id="2-1-网络分层">2.1 网络分层</h2>
<p>复杂的系统需要分层来考虑和解决，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</p>
<ol>
<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）。这样不同厂商可以专注于解决不同的事情，甚至不同厂商提供的设备，只要提供相同的接口就可以互相操作；</li>
<li><strong>提高了整体灵活性</strong>：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了；</li>
<li><strong>大问题化小</strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。需要注意有的时候，一台设备会处理多层的问题；</li>
</ol>
<h2 id="2-2-OSI-七层模型">2.2 OSI 七层模型</h2>
<p>OSI七层模型是国际标准化组织（ISO）提出一个网络分层模型，该模型由ISO这个国际化组织所主导。其大体结构以及每一层提供的功能如下图所示：</p>
<p><img src="20250505075146.png" alt="OSI七层模型"></p>
<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能。比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。上面这种图可能比较抽象，再来一个比较生动的图片。</p>
<p><img src="20250505080107.png" alt="OSI模型各层对应的具体协议和任务"></p>
<p>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。OSI 七层模型当时一直被一些大公司甚至一些国家政府支持，这样的背景下，实际上却并没有成为最后的实现样本，而是被另外一个协议簇TCP/IP所替代。</p>
<h2 id="2-3-TCP-IP模型">2.3 TCP/IP模型</h2>
<p>TCP/IP 四层模型是目前被广泛采用的一种模型，我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层<br>
<img src="20250505080534.png" alt="TCP/IP协议的四层模型"></li>
</ol>
<p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p>
<p><img src="20250505082225.png" alt="两个模型的对应"></p>
<h3 id="2-3-1-应用层（Application-layer）">2.3.1 应用层（Application layer）</h3>
<p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文（message/data）。</p>
<p><img src="20250505082932.png" alt="应用层的数据传输"></p>
<p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，比如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。应用层常见协议如下图所示：</p>
<p><img src="20250505083129.png" alt="应用层常见协议"></p>
<ul>
<li><strong>HTTP (Hypertext Transfer Protocol，超文本传输协议)</strong>：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的；</li>
<li><strong>SMTP (Simple Mail Transfer Protocol，简单邮件发送协议)</strong> ：基于 TCP 协议，是一种用于发送电子邮件的协议。⚠️注意 ：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议；</li>
<li><strong>POP3/IMAP (邮件接收协议)</strong>：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更加新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP；</li>
<li><strong>FTP (File Transfer Protocol，文件传输协议协议)</strong>：基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。⚠️注意 ：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP；</li>
<li><strong>Telnet (远程登陆协议)</strong>：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因；</li>
<li><strong>SSH (Secure Shell Protocol，安全的网络传输协议)</strong>：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务；</li>
<li><strong>RTP (Real-time Transport Protocol，实时传输协议}</strong>：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现；</li>
<li><strong>DNS (Domain Name System，域名管理系统}</strong>: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题；</li>
</ul>
<h3 id="2-3-2-传输层（Transport-layer）">2.3.2 传输层（Transport layer）</h3>
<p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。传输层常见协议：</p>
<p><img src="20250508203923.png" alt="传输层协议"></p>
<ul>
<li><strong>TCP (Transmission Control Protocol，传输控制协议 )</strong>：提供<strong>面向连接</strong>的，<strong>可靠</strong>的数据传输服务；</li>
<li><strong>UDP (User Datagram Protocol，用户数据协议)</strong>：提供<strong>无连接</strong>的，<strong>尽最大努力</strong>的数据传输服务（不保证数据传输的可靠性），简单高效；</li>
</ul>
<h4 id="面向连接与无连接的含义">面向连接与无连接的含义</h4>
<p>面向连接意味着在使用 TCP 协议进行数据传输之前，通信的双方（例如，客户端和服务器）必须先建立一个<strong>虚拟的连接</strong>。这个连接的建立过程通常被称为“三次握手”。建立连接的目的是为了在双方之间协商一些参数，并维护这个连接的状态信息，以便：</p>
<ul>
<li><strong>保证数据的可靠传输：</strong> TCP 会对每个发送的数据包进行编号，接收方会对收到的数据包进行确认。如果发送方在一定时间内没有收到确认，就会重新发送丢失的数据包，从而保证数据不会丢失；</li>
<li><strong>保证数据的顺序性：</strong> 数据包在网络中传输时可能会乱序到达。TCP 会根据数据包的编号将它们重新按顺序组装起来，确保接收方接收到的数据是完整且有序的；</li>
<li><strong>提供流量控制：</strong> TCP 能够根据接收方的处理能力和网络拥塞情况，动态地调整发送方的发送速率，防止数据发送过快导致接收方 overwhelmed 或网络拥堵；<br>
你可以将 TCP 的面向连接类比于打电话。在通话之前，你需要先拨号建立连接，对方接听后，双方才能开始交流。通话过程中，双方都知道对方的存在，并且可以确保说的话能够被对方听到（可靠性）。</li>
</ul>
<p>无连接意味着在使用 UDP 协议进行数据传输之前，通信的双方<strong>不需要建立任何预先的连接</strong>。发送方可以直接将数据封装成数据报（datagram），然后发送出去，而无需告知接收方，也无需等待接收方的确认。由于 UDP 是无连接的，它具有以下特点：</p>
<ul>
<li><strong>不可靠传输：</strong> UDP 不保证数据包一定能够到达接收方，也不保证数据包的顺序。数据包在传输过程中可能会丢失、重复或乱序到达；</li>
<li><strong>开销小，速度快：</strong> 由于省去了建立连接和维护连接状态的开销，以及数据包的确认和重传机制，UDP 的传输效率通常比 TCP 更高，延迟更小；</li>
</ul>
<p>你可以将 UDP 的无连接类比于寄信。你只需要知道对方的地址，就可以直接将信件寄出去，而无需事先与对方打招呼或确认对方是否准备好接收。你无法保证信件一定会被送达，也无法保证送达的顺序。</p>
<p><strong>总结来说：</strong></p>
<ul>
<li><strong>TCP 面向连接，可靠：</strong> 像打电话一样，先建立连接，再传输数据，保证数据的可靠性和顺序性。适用于对数据完整性要求高的场景，如网页浏览（HTTP）、文件传输（FTP）、电子邮件（SMTP）等；</li>
<li><strong>UDP 无连接，快速：</strong> 像寄信一样，直接发送数据，不建立连接，传输速度快，但可能丢包或乱序。适用于对实时性要求高，但可以容忍一定程度的数据丢失的场景，如在线视频、语音通话（VoIP）、在线游戏、DNS 查询等；</li>
</ul>
<h3 id="2-3-3-网络层（Network-Layer）">2.3.3 网络层（Network Layer）</h3>
<p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p>⚠️ 注意：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p>
<p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p>
<p><strong>网络层常见协议</strong>：<br>
<img src="20250509131452.png" alt="网络层常见协议"></p>
<ul>
<li><strong>IP (Internet Protocol，网际协议)</strong>：TCP/IP 协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6；</li>
<li><strong>ARP (Address Resolution Protocol，地址解析协议)</strong>：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题；</li>
<li><strong>ICMP (Internet Control Message Protocol，互联网控制报文协议)</strong>：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性；</li>
<li><strong>NAT (Network Address Translation，网络地址转换协议)</strong>：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置；</li>
<li><strong>OSPF (Open Shortest Path First，开放式最短路径优先)</strong> ：一种内部网关协议 （Interior Gateway Protocol, IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li>
<li><strong>RIP (Routing Information Protocol，路由信息协议)</strong>：一种内部网关协议（Interior Gateway Protocol, IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li>
<li><strong>BGP (Border Gateway Protocol，边界网关协议)</strong>：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性；</li>
</ul>
<h3 id="2-3-4-网络接口层（Network-Interface-Layer）">2.3.4 网络接口层（Network Interface Layer）</h3>
<p>我们可以把网络接口层看作是 OSI 模型中数据链路层和物理层的合体。</p>
<ul>
<li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。**数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）；</li>
<li>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异**</li>
</ul>
<p>网络接口层重要功能和协议如下图所示：</p>
<p><img src="20250509132218.png" alt="网络接口层"></p>
<h3 id="2-3-5-TCP-IP-模型和-OSI-模型的对应关系">2.3.5 TCP/IP 模型和 OSI 模型的对应关系</h3>
<p>以下是一个 OSI 模型和 TCP/IP 模型初略的对应关系。</p>
<p><img src="20250509132333.png" alt="对应关系"></p>
<h2 id="2-4-常见网络应用与协议">2.4 常见网络应用与协议</h2>
<h3 id="2-4-1-访问网页">2.4.1 访问网页</h3>
<p>的来说，网络通信模型可以用下图来表示，也就是大家只要熟记网络结构五层模型，按照这个体系，很多知识点都能顺出来了。访问网页的过程也是如此。</p>
<p>开始之前，我们先简单过一遍完整流程：</p>
<ol>
<li>在浏览器中输入指定网页的 URL。</li>
<li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li>
<li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li>
<li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li>
<li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li>
<li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li>
<li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li>
</ol>
<p>一切的开始——打开浏览器，在地址栏输入 URL，回车确认。那么，什么是 URL？访问 URL 有什么用？</p>
<h4 id="URL">URL</h4>
<p>URL（Uniform Resource Locators），即统一资源定位器。网络上的所有资源都靠 URL 来定位，每一个文件就对应着一个 URL，就像是路径地址。理论上，文件资源和 URL 一一对应。实际上也有例外，比如某些 URL 指向的文件已经被重定位到另一个位置，这样就有多个 URL 指向同一个文件。</p>
<p>**URL 的组成结构<br>
<img src="20250509133125.png" alt="URL的组成"></p>
<ul>
<li>协议。URL 的前缀通常表示了该网址采用了何种应用层协议，通常有两种——HTTP 和 HTTPS。当然也有一些不太常见的前缀头，比如文件传输时用到的<code>ftp:</code>；</li>
<li>域名。域名便是访问网址的通用名，这里也有可能是网址的 IP 地址，域名可以理解为 IP 地址的可读版本，毕竟绝大部分人都不会选择记住一个网址的 IP 地址；</li>
<li>端口。如果指明了访问网址的端口的话，端口会紧跟在域名后面，并用一个冒号隔开；</li>
<li>资源路径。域名（端口）后紧跟的就是资源路径，从第一个<code>/</code>开始，表示从服务器上根目录开始进行索引到的文件路径，上图中要访问的文件就是服务器根目录下<code>/path/to/myfile.html</code>。早先的设计是该文件通常物理存储于服务器主机上，但现在随着网络技术的进步，该文件不一定会物理存储在服务器主机上，有可能存放在云上，而文件路径也有可能是虚拟的（遵循某种规则）；</li>
<li>参数。参数是浏览器在向服务器提交请求时，在 URL 中附带的参数。服务器解析请求时，会提取这些参数。参数采用键值对的形式<code>key=value</code>，每一个键值对使用<code>&amp;</code>隔开。参数的具体含义和请求操作的具体方法有关；</li>
<li>锚点。锚点顾名思义，是在要访问的页面上的一个锚。要访问的页面大部分都多于一页，如果指定了锚点，那么在客户端显示该网页是就会定位到锚点处，相当于一个小书签。值得一提的是，在 URL 中，锚点以<code>#</code>开头，并且<strong>不会</strong>作为请求的一部分发送给服务端；</li>
</ul>
<h4 id="DNS">DNS</h4>
<p>键入了 URL 之后，第一个重头戏登场——DNS 服务器解析。DNS (Domain Name System) 域名系统，要解决的是 <strong>域名和 IP 地址的映射问题</strong> 。毕竟，域名只是一个网址便于记住的名字，而网址真正存在的地址其实是 IP 地址。</p>
<p><img src="20250509133458.png" alt="DNS解析过程"></p>
<p>目前 DNS 的设计采用的是分布式、层次数据库结构，<strong>DNS 是应用层协议，基于 UDP 协议之上，端口为 53</strong> 。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/osi-and-tcp-ip-model.html">OSI 和 TCP/IP 网络分层模型详解（基础） | JavaGuide</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://alifespace.github.io">lifespace</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://alifespace.github.io/2025/04/02/ai/pc-structure-002/">https://alifespace.github.io/2025/04/02/ai/pc-structure-002/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://alifespace.github.io" target="_blank">生命不息，学习不止</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/ai-classroom/tags/TCP-IP/">TCP/IP</a><a class="post-meta__tags" href="/ai-classroom/tags/OSI/">OSI</a></div><div class="post-share"><div class="social-share" data-image="/ai-classroom/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/ai-classroom/2025/05/01/ai/pc-common-001/" title="第一章 计算机常用知识"><img class="cover" src="/ai-classroom/2025/05/01/ai/pc-common-001/cover.jpg" onerror="onerror=null;src='/ai-classroom/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">第一章 计算机常用知识</div></div><div class="info-2"><div class="info-item-1">1.1 操作系统 操作系统（Operating System, OS）就是一台电脑或手机的大管家 + 指挥中心。它不创造内容，但它安排一切、管理一切、协调一切。没有它，电脑和手机就是一堆金属和电路板，啥也干不了。 1.1.1 操作系统的 4 个核心作用（类比说明）    功能 类比 简单解释     1️⃣ 管理硬件 操场管理者 负责谁什么时候使用 CPU（大脑）、内存（白板）、硬盘（资料室）   2️⃣ 运行程序 课堂安排表 安排你打开的各种程序（微信、Word、浏览器），让它们互不打架   3️⃣ 文件系统 图书管理员 把杂乱的硬盘数据整理成文件夹、文件，便于保存和查找   4️⃣ 用户交互 服务员 你点鼠标、敲键盘、触屏，操作系统把这些变成电脑能理解的动作    1.1.2 32位系统与64位系统 32位系统与64位系统的主要区别体现在处理器的架构能力、内存寻址范围、以及软件支持等方面。首先我们要知道32位和64位指的是什么。其实这是根据CPU内的寄存器字长来确定的，计算机内部数据都是二进制来呈现的，32位的计算机CPU一次最多能处理32位的二进制数据，而64位的计算机CP...</div></div></div></a><a class="pagination-related" href="/ai-classroom/2025/04/01/ai/pc-structure-001/" title="第一章 计算机组成原理和架构"><img class="cover" src="/ai-classroom/2025/04/01/ai/pc-structure-001/cover.png" onerror="onerror=null;src='/ai-classroom/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第一章 计算机组成原理和架构</div></div><div class="info-2"><div class="info-item-1">从本章开始将介绍计算机组成结构，从硬件的角度来看看计算机是怎样构成的，冯·诺依曼结构是现代计算机的结构理论模型。本章从冯·诺依曼的理论模型开始，介绍计算机系统的各个组成部分，并与现代计算机的具体实现相对应。 2.1 冯·诺依曼结构 现代计算机都采用存储程序结构，又称为冯·诺依曼结构，是1945年匈牙利籍数学家冯·诺依曼受宾夕法尼亚大学研制的ENIAC计算机结构的启发提出的，是世界上第一个完整的计算机体系结构。 冯·诺依曼结构的主要特点是：计算机由存储器、运算器、控制器、输入设备和输出设备五部分组成。  运算器和控制器合称为中央处理器（Central Processing Processor，简称CPU）； 存储器是按地址访问的线性编址的一维结构，每个单元的位数固定； 采用存储程序方式，即指令和数据不加区别混合存储在同一个存储器中； 控制器通过执行指令发出控制信号控制计算机的操作。指令在存储器中按其执行顺序存放，由指令计数器指明要执行的指令所在的单元地址。指令计数器一般按顺序递增，但执行顺序可按运算结果或当时的外界条件而改变； 以运算器为中心，输入输出设备与存储器之间的数据传送都经...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/ai-classroom/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/ai-classroom/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lifespace</div><div class="author-info-description"></div><div class="site-data"><a href="/ai-classroom/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/ai-classroom/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/ai-classroom/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第二章 OSI 和 TCP&#x2F;IP 网络分层模型详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82"><span class="toc-text">2.1 网络分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.2 OSI 七层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-TCP-IP%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.3 TCP&#x2F;IP模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88Application-layer%EF%BC%89"><span class="toc-text">2.3.1 应用层（Application layer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%88Transport-layer%EF%BC%89"><span class="toc-text">2.3.2 传输层（Transport layer）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">面向连接与无连接的含义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88Network-Layer%EF%BC%89"><span class="toc-text">2.3.3 网络层（Network Layer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82%EF%BC%88Network-Interface-Layer%EF%BC%89"><span class="toc-text">2.3.4 网络接口层（Network Interface Layer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-TCP-IP-%E6%A8%A1%E5%9E%8B%E5%92%8C-OSI-%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-text">2.3.5 TCP&#x2F;IP 模型和 OSI 模型的对应关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E4%B8%8E%E5%8D%8F%E8%AE%AE"><span class="toc-text">2.4 常见网络应用与协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5"><span class="toc-text">2.4.1 访问网页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#URL"><span class="toc-text">URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS"><span class="toc-text">DNS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-text">参考文献</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/ai-classroom/2025/07/07/games/diablo2/d2-007/" title="暗黑破坏神2 --- 第七章 Build 刺客"><img src="/ai-classroom/2025/07/07/games/diablo2/d2-007/cover.jpg" onerror="this.onerror=null;this.src='/ai-classroom/img/404.jpg'" alt="暗黑破坏神2 --- 第七章 Build 刺客"/></a><div class="content"><a class="title" href="/ai-classroom/2025/07/07/games/diablo2/d2-007/" title="暗黑破坏神2 --- 第七章 Build 刺客">暗黑破坏神2 --- 第七章 Build 刺客</a><time datetime="2025-07-07T17:24:57.000Z" title="发表于 2025-07-07 10:24:57">2025-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ai-classroom/2025/07/06/games/diablo2/d2-006/" title="暗黑破坏神2 --- 第六章 Build 魔法使"><img src="/ai-classroom/2025/07/06/games/diablo2/d2-006/cover.webp" onerror="this.onerror=null;this.src='/ai-classroom/img/404.jpg'" alt="暗黑破坏神2 --- 第六章 Build 魔法使"/></a><div class="content"><a class="title" href="/ai-classroom/2025/07/06/games/diablo2/d2-006/" title="暗黑破坏神2 --- 第六章 Build 魔法使">暗黑破坏神2 --- 第六章 Build 魔法使</a><time datetime="2025-07-06T19:14:46.000Z" title="发表于 2025-07-06 12:14:46">2025-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ai-classroom/2025/07/05/games/diablo2/d2-005/" title="暗黑破坏神2 --- 第五章 Build 佣兵米山"><img src="/ai-classroom/2025/07/05/games/diablo2/d2-005/cover.jpg" onerror="this.onerror=null;this.src='/ai-classroom/img/404.jpg'" alt="暗黑破坏神2 --- 第五章 Build 佣兵米山"/></a><div class="content"><a class="title" href="/ai-classroom/2025/07/05/games/diablo2/d2-005/" title="暗黑破坏神2 --- 第五章 Build 佣兵米山">暗黑破坏神2 --- 第五章 Build 佣兵米山</a><time datetime="2025-07-06T04:17:16.000Z" title="发表于 2025-07-05 21:17:16">2025-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ai-classroom/2025/07/03/games/diablo2/d2-003/" title="暗黑破坏神3 --- 第三章 物品掉落机制及刷宝"><img src="/ai-classroom/2025/07/03/games/diablo2/d2-003/cover.jpg" onerror="this.onerror=null;this.src='/ai-classroom/img/404.jpg'" alt="暗黑破坏神3 --- 第三章 物品掉落机制及刷宝"/></a><div class="content"><a class="title" href="/ai-classroom/2025/07/03/games/diablo2/d2-003/" title="暗黑破坏神3 --- 第三章 物品掉落机制及刷宝">暗黑破坏神3 --- 第三章 物品掉落机制及刷宝</a><time datetime="2025-07-03T19:14:41.000Z" title="发表于 2025-07-03 12:14:41">2025-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ai-classroom/2025/07/01/games/diablo2/d2-001/" title="暗黑破坏神2 --- 第一章 总论"><img src="/ai-classroom/2025/07/01/games/diablo2/d2-001/cover.avif" onerror="this.onerror=null;this.src='/ai-classroom/img/404.jpg'" alt="暗黑破坏神2 --- 第一章 总论"/></a><div class="content"><a class="title" href="/ai-classroom/2025/07/01/games/diablo2/d2-001/" title="暗黑破坏神2 --- 第一章 总论">暗黑破坏神2 --- 第一章 总论</a><time datetime="2025-07-01T17:06:39.000Z" title="发表于 2025-07-01 10:06:39">2025-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2019 - 2025 By lifespace</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/ai-classroom/js/utils.js?v=5.4.0-b2"></script><script src="/ai-classroom/js/main.js?v=5.4.0-b2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>